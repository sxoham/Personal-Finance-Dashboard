// MultipleFiles/script.js
document.addEventListener("DOMContentLoaded", () => {
    let transactions = [];
    let currentUser = null;
    let selectedMonth = new Date().getMonth();
    let selectedYear = new Date().getFullYear();

    // === Chart Setup ===
    let incomeExpenseLineChart = null;
    let expensesCategoryChart = null;

    // === UI Elements ===
    const monthFilter = document.getElementById('monthFilter');
    const yearFilter = document.getElementById('yearFilter');

    // === Custom Message Box ===
    function showMessageBox(message) {
        const overlay = document.getElementById('customMessageBox');
        document.getElementById('messageBoxText').textContent = message;
        overlay.classList.add('show');
        document.getElementById('messageBoxCloseBtn').onclick = () => overlay.classList.remove('show');
    }

    // === Firebase Auth ===
    auth.onAuthStateChanged(user => {
        if (!user) return window.location.href = "login.html";
        currentUser = user;
        db.collection("users").doc(user.uid).get().then(doc => {
            if (doc.exists && doc.data().transactions) {
                transactions = doc.data().transactions.map((tx, i) => ({ ...tx, id: tx.id || Date.now() + i }));
            }
            processRecurringTransactions();
            populateDateFilters();
            updateDashboard();
            renderFilteredTransactions();
        }).catch(error => console.error("Error fetching user data:", error));
    });

    // === Recurring Transactions Logic ===
    function processRecurringTransactions() {
        const now = new Date();
        let addedTransactions = false;
        // Filter for recurring templates that are still active (repeat: true)
        const recurringTemplates = transactions.filter(tx => tx.repeat && !tx.autoGenerated);

        recurringTemplates.forEach(template => {
            const templateDate = new Date(template.date.split('/').reverse().join('-'));
            // Start checking from the month after the template's date
            let startDate = new Date(templateDate.getFullYear(), templateDate.getMonth() + 1, 1);

            while (startDate <= now) {
                const month = startDate.getMonth();
                const year = startDate.getFullYear();
                const alreadyExists = transactions.some(tx =>
                    tx.autoGenerated && tx.recurringId === template.id &&
                    new Date(tx.date.split('/').reverse().join('-')).getMonth() === month &&
                    new Date(tx.date.split('/').reverse().join('-')).getFullYear() === year
                );

                if (!alreadyExists) {
                    const newDate = new Date(year, month, templateDate.getDate());
                    // Ensure the new transaction is marked as autoGenerated and links to its recurringId
                    transactions.push({ ...template, id: Date.now() + Math.random(), recurringId: template.id, date: formatDate(newDate), autoGenerated: true });
                    addedTransactions = true;
                }
                startDate.setMonth(startDate.getMonth() + 1);
            }
        });
        if (addedTransactions) saveData(false);
    }

    // Function to cancel future repetitions of a transaction
    function cancelRecurringTransaction(recurringId) {
        const templateIndex = transactions.findIndex(tx => tx.id === recurringId && !tx.autoGenerated);
        if (templateIndex > -1) {
            transactions[templateIndex].repeat = false; // Mark the original template as not repeating
            saveData(true); // Save changes to Firebase
            showMessageBox("Future repetitions cancelled for this transaction.");
            fullUpdate(); // Re-render dashboard to reflect changes
        } else {
            showMessageBox("Could not find the original recurring transaction to cancel.");
        }
    }

    // === Form & Filters ===
    document.getElementById('transactionForm').addEventListener('submit', function (e) {
        e.preventDefault();
        const date = document.getElementById('date').value;
        transactions.push({
            id: Date.now(),
            date: formatDate(date || new Date()),
            category: document.getElementById('category').value.trim(),
            amount: parseFloat(document.getElementById('amount').value),
            type: document.getElementById('type').value,
            repeat: document.getElementById('repeat').checked,
            autoGenerated: false // Manually added transactions are not auto-generated
        });
        this.reset();
        document.getElementById('date').valueAsDate = new Date();
        fullUpdate();
        showMessageBox("Transaction added successfully!");
    });
    
    document.getElementById('date').valueAsDate = new Date();
    
    monthFilter.addEventListener('change', () => {
        selectedMonth = parseInt(monthFilter.value);
        renderFilteredTransactions();
    });
    
    yearFilter.addEventListener('change', () => {
        selectedYear = parseInt(yearFilter.value);
        renderFilteredTransactions();
    });

    function populateDateFilters() {
        const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
        monthFilter.innerHTML = monthNames.map((m, i) => `<option value="${i}">${m}</option>`).join('');

        const years = [...new Set(transactions.map(tx => new Date(tx.date.split('/').reverse().join('-')).getFullYear()))];
        const currentYr = new Date().getFullYear();
        if (!years.includes(currentYr)) years.push(currentYr);
        yearFilter.innerHTML = years.sort((a,b) => b-a).map(y => `<option value="${y}">${y}</option>`).join('');
        
        monthFilter.value = selectedMonth;
        yearFilter.value = selectedYear;
    }

    // === Main Update Functions ===
    function fullUpdate() {
        populateDateFilters();
        updateDashboard();
        renderFilteredTransactions();
    }

    function updateDashboard() {
        const now = new Date();
        const currentMonth = now.getMonth();
        const currentYear = now.getFullYear();

        const prevMonthDate = new Date(now.getFullYear(), now.getMonth() - 1, 1);
        const prevMonth = prevMonthDate.getMonth();
        const prevMonthYear = prevMonthDate.getFullYear();

        let totalIncome = 0, totalExpense = 0;
        let currentMonthIncome = 0, currentMonthExpenses = 0;
        let prevMonthIncome = 0, prevMonthExpenses = 0;
        const categoryExpenses = {};
        const monthlyChartData = {};
        
        transactions.forEach(tx => {
            const txDate = new Date(tx.date.split('/').reverse().join('-'));
            const txMonth = txDate.getMonth();
            const txYear = txDate.getFullYear();
            
            if (tx.type === "income") totalIncome += tx.amount;
            else totalExpense += tx.amount;
            
            if (txYear === currentYear && txMonth === currentMonth) {
                if (tx.type === 'income') currentMonthIncome += tx.amount;
                else currentMonthExpenses += tx.amount;
            } else if (txYear === prevMonthYear && txMonth === prevMonth) {
                if (tx.type === 'income') prevMonthIncome += tx.amount;
                else prevMonthExpenses += tx.amount;
            }

            if (tx.type === 'expense') categoryExpenses[tx.category] = (categoryExpenses[tx.category] || 0) + tx.amount;
            
            const monthYearKey = `${txDate.toLocaleString('default', { month: 'short' })} '${String(txYear).slice(-2)}`;
            if (!monthlyChartData[monthYearKey]) monthlyChartData[monthYearKey] = { income: 0, expenses: 0, date: new Date(txYear, txMonth, 1) };
            if (tx.type === 'income') monthlyChartData[monthYearKey].income += tx.amount;
            else monthlyChartData[monthYearKey].expenses += tx.amount;
        });

        const totalBalance = totalIncome - totalExpense;
        document.getElementById('totalBalance').textContent = `₹${totalBalance.toLocaleString('en-IN')}`;
        document.getElementById('summarySavings').textContent = `₹${totalBalance.toLocaleString('en-IN')}`;
        
        const incomeChange = calculatePercentageChange(currentMonthIncome, prevMonthIncome);
        document.getElementById('summaryIncome').innerHTML = `₹${currentMonthIncome.toLocaleString('en-IN')} <span class="${incomeChange.class}">${incomeChange.text}</span>`;
        
        const expenseChange = calculatePercentageChange(currentMonthExpenses, prevMonthExpenses);
        document.getElementById('summaryExpenses').innerHTML = `₹${currentMonthExpenses.toLocaleString('en-IN')} <span class="${expenseChange.class}">${expenseChange.text}</span>`;

        updateCharts(monthlyChartData, categoryExpenses);
    }
    
    function calculatePercentageChange(current, previous) {
        if (previous === 0) {
            return current > 0 ? { text: '↑', class: 'change-indicator up' } : { text: '', class: 'change-indicator' };
        }
        const change = ((current - previous) / previous) * 100;
        if (Math.abs(change) < 0.1) return { text: '', class: 'change-indicator' };
        
        const indicator = change > 0 ? '↑' : '↓';
        const cssClass = change > 0 ? 'up' : 'down';
        return { text: `${indicator} ${Math.abs(change).toFixed(1)}%`, class: `change-indicator ${cssClass}` };
    }

    function updateCharts(monthlyData, categoryData) {
        const sortedMonths = Object.values(monthlyData).sort((a, b) => a.date - b.date).slice(-7);
        const labels = sortedMonths.map(m => m.date.toLocaleString('default', { month: 'short' }) + ` '${String(m.date.getFullYear()).slice(-2)}`);
        
        if (incomeExpenseLineChart) incomeExpenseLineChart.destroy();
        incomeExpenseLineChart = new Chart(document.getElementById('incomeExpenseLineChart').getContext('2d'), {
            type: 'line', data: { labels, datasets: [{ label: 'Income', data: sortedMonths.map(m => m.income), borderColor: '#4CAF50', backgroundColor: 'rgba(76, 175, 80, 0.1)', fill: true, tension: 0.4 }, { label: 'Expenses', data: sortedMonths.map(m => m.expenses), borderColor: '#F44336', backgroundColor: 'rgba(244, 67, 54, 0.1)', fill: true, tension: 0.4 }] }, options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true } } }
        });

        if (expensesCategoryChart) expensesCategoryChart.destroy();
        expensesCategoryChart = new Chart(document.getElementById('expensesCategoryChart').getContext('2d'), {
            type: 'doughnut', data: { labels: Object.keys(categoryData), datasets: [{ data: Object.values(categoryData), backgroundColor: ['#2196F3', '#FFC107', '#4CAF50', '#F44336', '#9C27B0', '#00BCD4'], hoverOffset: 4 }] }, options: { responsive: true, maintainAspectRatio: false }
        });
    }

    // === Transaction Rendering & Deletion ===
    function renderFilteredTransactions() {
        const listDiv = document.querySelector(".transactions-list");
        listDiv.innerHTML = "";
        
        const filtered = transactions.filter(tx => {
            const txDate = new Date(tx.date.split('/').reverse().join('-'));
            return txDate.getMonth() === selectedMonth && txDate.getFullYear() === selectedYear;
        }).sort((a,b) => new Date(b.date.split('/').reverse().join('-')) - new Date(a.date.split('/').reverse().join('-')));
        
        if (filtered.length === 0) {
            listDiv.innerHTML = "<p>No transactions for this month.</p>";
            return;
        }

        filtered.forEach(tx => {
            const item = document.createElement("div");
            item.classList.add("transaction-item");
            const iconClass = tx.type === 'expense' ? 'fa-wallet' : 'fa-dollar-sign';
            item.innerHTML = `
                <div class="transaction-icon ${tx.type}-icon"><i class="fas ${iconClass}"></i></div>
                <div class="transaction-details">
                    <p>${tx.category}</p>
                    <span class="date">${tx.date} 
                        ${tx.repeat ? '<i class="fas fa-sync-alt" title="Repeats monthly"></i>' : ''}
                        ${!tx.autoGenerated && tx.repeat ? `<button class="cancel-repeat-btn" data-id="${tx.id}" title="Cancel future repetitions"><i class="fas fa-ban"></i></button>` : ''}
                    </span>
                </div>
                <div class="transaction-actions">
                    <div class="transaction-amount ${tx.type}">${tx.type === 'expense' ? '-' : '+'}₹${tx.amount.toLocaleString('en-IN')}</div>
                    <button class="delete-btn" data-id="${tx.id}" title="Remove"><i class="fas fa-trash"></i></button>
                </div>`;
            listDiv.appendChild(item);
        });
    }

    document.querySelector(".transactions-list").addEventListener('click', e => {
        if (e.target.closest('.delete-btn')) {
            const id = Number(e.target.closest('.delete-btn').dataset.id);
            const index = transactions.findIndex(tx => tx.id === id);
            if (index > -1) {
                transactions.splice(index, 1);
                fullUpdate();
            }
        } else if (e.target.closest('.cancel-repeat-btn')) {
            const id = Number(e.target.closest('.cancel-repeat-btn').dataset.id);
            cancelRecurringTransaction(id);
        }
    });
    
    // === Utilities & Data Management ===
    function formatDate(d) {
        const date = new Date(d);
        return `${String(date.getDate()).padStart(2, '0')}/${String(date.getMonth() + 1).padStart(2, '0')}/${date.getFullYear()}`;
    }

    function saveData(showMessage = true) {
        if (!currentUser) return showMessageBox("Please log in.");
        // When saving, ensure that autoGenerated transactions don't have the 'repeat' flag set to true,
        // as only the original template should control repetition.
        const dataToSave = transactions.map(({ id, ...tx }) => {
            if (tx.autoGenerated) {
                return { ...tx, repeat: false }; // Auto-generated transactions should not be marked as repeating
            }
            return tx;
        });
        db.collection("users").doc(currentUser.uid).set({ transactions: dataToSave })
            .then(() => { if (showMessage) showMessageBox("Data saved!"); })
            .catch(err => showMessageBox(`Save failed: ${err.message}`));
    }
    document.getElementById("saveDataBtn").addEventListener("click", () => saveData(true));

    document.getElementById("logoutBtn").addEventListener("click", () => auth.signOut());
});
